#[allow(unused_imports)]
use anyhow::{Context, Result};
use chrono::{DateTime, Local};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

use crate::auth::{User, Session};
use crate::todo::{Todo, Status, Priority};

#[derive(Clone)]
pub struct Storage {
    data_dir: PathBuf,
    users_file: PathBuf,
    todos_file: PathBuf,
    session_file: PathBuf,
    markdown_file: PathBuf,
}

impl Storage {
    pub fn new() -> Result<Self> {
        let data_dir = dirs::home_dir()
            .context("Failed to get home directory")?
            .join(".todo-cli");
        
        // Create data directory if it doesn't exist
        fs::create_dir_all(&data_dir)
            .context("Failed to create data directory")?;
        
        let users_file = data_dir.join("users.json");
        let todos_file = data_dir.join("todos.json");
        let session_file = data_dir.join("session.json");
        let markdown_file = data_dir.join("todos.md");
        
        Ok(Self {
            data_dir,
            users_file,
            todos_file,
            session_file,
            markdown_file,
        })
    }
    
    pub fn load_users(&self) -> Result<HashMap<String, User>> {
        if !self.users_file.exists() {
            return Ok(HashMap::new());
        }
        
        let content = fs::read_to_string(&self.users_file)
            .context("Failed to read users file")?;
        
        let users: HashMap<String, User> = serde_json::from_str(&content)
            .context("Failed to parse users file")?;
        
        Ok(users)
    }
    
    pub fn save_users(&self, users: &HashMap<String, User>) -> Result<()> {
        let content = serde_json::to_string_pretty(users)
            .context("Failed to serialize users")?;
        
        fs::write(&self.users_file, content)
            .context("Failed to write users file")?;
        
        Ok(())
    }
    
    pub fn load_todos(&self) -> Result<HashMap<String, Todo>> {
        if !self.todos_file.exists() {
            return Ok(HashMap::new());
        }
        
        let content = fs::read_to_string(&self.todos_file)
            .context("Failed to read todos file")?;
        
        let todos: HashMap<String, Todo> = serde_json::from_str(&content)
            .context("Failed to parse todos file")?;
        
        Ok(todos)
    }
    
    pub fn save_todos(&self, todos: &HashMap<String, Todo>) -> Result<()> {
        let content = serde_json::to_string_pretty(todos)
            .context("Failed to serialize todos")?;
        
        fs::write(&self.todos_file, content)
            .context("Failed to write todos file")?;
        
        Ok(())
    }
    
    pub fn load_session(&self) -> Result<Option<Session>> {
        if !self.session_file.exists() {
            return Ok(None);
        }
        
        let content = fs::read_to_string(&self.session_file)
            .context("Failed to read session file")?;
        
        let session: Session = serde_json::from_str(&content)
            .context("Failed to parse session file")?;
        
        Ok(Some(session))
    }
    
    pub fn save_session(&self, session: &Session) -> Result<()> {
        let content = serde_json::to_string_pretty(session)
            .context("Failed to serialize session")?;
        
        fs::write(&self.session_file, content)
            .context("Failed to write session file")?;
        
        Ok(())
    }
    
    pub fn clear_session(&self) -> Result<()> {
        if self.session_file.exists() {
            fs::remove_file(&self.session_file)
                .context("Failed to remove session file")?;
        }
        Ok(())
    }
    
    pub fn append_to_markdown(&self, todo: &Todo) -> Result<()> {
        let markdown_content = self.format_todo_markdown(todo);
        
        if !self.markdown_file.exists() {
            let header = format!("# Todo List\n\nGenerated by Todo CLI\n\n---\n\n");
            fs::write(&self.markdown_file, header)
                .context("Failed to create markdown file")?;
        }
        
        let mut existing_content = fs::read_to_string(&self.markdown_file)
            .context("Failed to read markdown file")?;
        
        existing_content.push_str(&markdown_content);
        
        fs::write(&self.markdown_file, existing_content)
            .context("Failed to write to markdown file")?;
        
        Ok(())
    }
    
    pub fn update_markdown_todo(&self, updated_todo: &Todo) -> Result<()> {
        self.regenerate_markdown()?;
        Ok(())
    }
    
    pub fn remove_from_markdown(&self, _todo: &Todo) -> Result<()> {
        self.regenerate_markdown()?;
        Ok(())
    }
    
    fn regenerate_markdown(&self) -> Result<()> {
        let todos = self.load_todos()?;
        let users = self.load_users()?;
        
        let mut content = String::new();
        content.push_str("# Todo List\n\n");
        content.push_str(&format!("Generated by Todo CLI on {}\n\n", Local::now().format("%Y-%m-%d %H:%M:%S")));
        content.push_str("---\n\n");
        
        // Group todos by user
        let mut todos_by_user: HashMap<String, Vec<&Todo>> = HashMap::new();
        for todo in todos.values() {
            todos_by_user.entry(todo.user_id.clone()).or_default().push(todo);
        }
        
        for (user_id, user_todos) in todos_by_user {
            if let Some(user) = users.get(&user_id) {
                content.push_str(&format!("## {} ({})\n\n", user.username, user.email));
                
                // Separate by status
                let pending: Vec<&Todo> = user_todos.iter()
                    .filter(|t| t.status == Status::Pending)
                    .cloned()
                    .collect();
                let completed: Vec<&Todo> = user_todos.iter()
                    .filter(|t| t.status == Status::Completed)
                    .cloned()
                    .collect();
                
                if !pending.is_empty() {
                    content.push_str("### ðŸ“‹ Pending Tasks\n\n");
                    for todo in pending {
                        content.push_str(&self.format_todo_markdown(todo));
                    }
                    content.push('\n');
                }
                
                if !completed.is_empty() {
                    content.push_str("### âœ… Completed Tasks\n\n");
                    for todo in completed {
                        content.push_str(&self.format_todo_markdown(todo));
                    }
                    content.push('\n');
                }
                
                content.push_str("---\n\n");
            }
        }
        
        fs::write(&self.markdown_file, content)
            .context("Failed to write markdown file")?;
        
        Ok(())
    }
    
    fn format_todo_markdown(&self, todo: &Todo) -> String {
        let status_checkbox = match todo.status {
            Status::Pending => "- [ ]",
            Status::Completed => "- [x]",
        };
        
        let priority_emoji = match todo.priority {
            Priority::Low => "ðŸŸ¢",
            Priority::Medium => "ðŸŸ¡",
            Priority::High => "ðŸ”´",
        };
        
        let id_short = &todo.id[..8];
        let mut content = format!("{} {} **{}** `{}`\n", 
            status_checkbox, priority_emoji, todo.title, id_short);
        
        if let Some(ref description) = todo.description {
            content.push_str(&format!("  > {}\n", description));
        }
        
        if let Some(due_date) = todo.due_date {
            let due_datetime = DateTime::<Local>::from_naive_utc_and_offset(due_date, *Local::now().offset());
            content.push_str(&format!("  ðŸ“… **Due:** {}\n", due_datetime.format("%Y-%m-%d %H:%M")));
        }
        
        content.push_str(&format!("  ðŸ•’ **Created:** {}\n", 
            todo.created_at.format("%Y-%m-%d %H:%M")));
        
        if todo.created_at != todo.updated_at {
            content.push_str(&format!("  ðŸ”„ **Updated:** {}\n", 
                todo.updated_at.format("%Y-%m-%d %H:%M")));
        }
        
        content.push('\n');
        content
    }
}